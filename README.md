# Java

Banuprakash C

Full Stack Architect, Corporate Trainer

Co-founder & CTO: Lucida Technologies Pvt Ltd., 

Email: banuprakashc@yahoo.co.in; banuprakash.cr@gmail.com; banu@lucidatechnologies.com

https://www.linkedin.com/in/banu-prakash-50416019/

https://github.com/BanuPrakash/NCG_Java

===================================

Softwares Required:
1)  openJDK 17
https://jdk.java.net/java-se-ri/17

2) IntelliJ Ultimate edition 
https://www.jetbrains.com/idea/download/?section=mac


3) MySQL on Docker

Install Docker Desktop

Docker steps:

```
a) docker pull mysql

b) docker run --name local-mysql â€“p 3306:3306 -e MYSQL_ROOT_PASSWORD=Welcome123 -d mysql

container name given here is "local-mysql"

For Mac:
docker run -p 3306:3306 -d --name local-mysql -e MYSQL_ROOT_PASSWORD=Welcome123 mysql


c) CONNECT TO A MYSQL RUNNING CONTAINER:

$ docker exec -t -i local-mysql bash

d) Run MySQL client:

bash terminal> mysql -u "root" -p

mysql> exit

```

OOP 

--> Programs which resemble real world application
Object communicates with other object by sending messages. What messages an object can take is exposed thro its interface.

Object --> state and behaviour

SOLID design principle

S --> Single Responsibility
O --> open Close Principle [ Closed for Change  & open for extension]
L --> Liskov Substitution Principle
    Genralization and Specialization 
I --> Interface Seggregation
D --> Dependency Injection

===========================

Java ?
Java is a technology which has a platform to run/execute bytecode

Byte code can be generated by using different programming languages / Compilers

Java programming language --> JDK --> javac
Kotlin --> KDK --> Kotlin Compiler
Groovy --> GDK --> Groovy compiler

Compile time Environment:
```
public class Account {
    private double balance ; // state
    private static int count; // state of class
    
    public Account() {
        count++;
    }
    
    public void deposit(double amt) {
        this.balance += amt;
    }

    public double getBalance() {
        return this.balance;
    }

    public static int getCount() {
        return count;
    }
}

javac Account.java ---> Account.class


public class AccountExample {
    public static void main(String[] args) {
        Account rahulAcc = new Account();
        rahulAcc.deposit(45000);

        System.out.println(Account.getCount()); // 1
        Account swethaAcc = new Account();
        swethaAcc.deposit(50000);

        System.out.println(swethaAcc.getBalance());
         System.out.println(Account.getCount()); // 2
    }
}

javac AccountExample.java --> AccountExample.class

```

JRE --> Java Runtime Environment

1) ClassLoader
    findLoadedClass(), 
    loadClass(), --> Classpath ENV variable
    findSystemClass()
    defineClass() --> Convert Bytecode to system specific DataStructure

2 java AccountExample [JRE --> classLoader]
2.1) classloader
2.2) Main Thread is started --> Unit of Work

 public void deposit(double amt) {
translate to:
public void deposit(Account this, double amt) {
    this.balance += amt;
}
context.behaviour(arguments);
rahulAcc.deposit(45000); ==> deposit(rahulAcc, 45000);

===========

Logically Grouping of classes/Object
1) Entity class
    business data
    Example:
    a) Uber
    Customer, Vehicle, Driver, Payment, Trip ...

    b) Swiggy
    Customer, Product, Order, LineItemm Payment, ShipAddress

    These classes contains instance variables / state, constructorss, getters and setters, hashCode, equals

    ``
    public class Customer {
        String email;
        String firstName;
        ...

    }
    ```
2) DAO: Data Access Object
    they contain CRUD operaions
    CREATE READ UPDATE and DELETE operations
    generally one per table
    ```
    public class CustomerDao {
        public void register(Customer c) {
            "INSERT into customers.."
    
        }

        public boolean login(Customer c) {
            select ...
        }
    }
    ```
3) Business Class:
    business logic
4) Service classes : are a facade over DAO and business class
    generally one per actor

```
    public class BankingService {

        public void transferFunds(Account fromAcc, Account toAcc, double amt) {
            accountDao.getBalance(fromAcc); // 
            businessLogic.checkEligible();
            accounDao.updateAccount(fromAcc);
            accountDao.updateAccount(toAcc);
            transactionDao.insertTx(fromAcc, toAcc);
            sendSMS()
            sendEMail();
        }

    }

```
5) Client
    Web Client / Desktop client / Mobile Client / Hardware ...

6) Utility classes : Helpers
7) Exception classes: to represent any abnormal condition in application
    Why?
    a) What went wrong
    b) Why?
    c) Where?

----

packages: folders for grouping related classes

``
com
 |
 adobe
    |
    aem
     |
     entity
        Customer.class
        Product.class
     dao
        CustomerDao.class
        Product.class
    service
        CustomerService.class

```

Relationship between Objects:
1) Generalization and Specialization
2) Realization
3) Uses A relationship
4) Association


Generalization and Specialization: Inheritance ==> IS A relationship

Mobile m = new Mobile(); memory is created for id, nam, price and connectivity
all the methods of Product + getter and setter for connectivity;

m.setPrice(3333); // is this valid?

Product p = new Mobile(); 
p.setPrice(4444); // valid
p.setConnectivty("5G"); ???? 
p.isExpensive(); // which method --> calls method in Mobile and not Product class --> dynamic binding

instance methods are dynamic binding / runtime binding
static methods are compile time bindings
all instance methods in Java are virtual by default.

static methods --> don't call overriding --> shadowing
variables --> shadowing

======

abstract keyword
1) use it with class to specify that it's too generic, can't exist in real world
can't instantiate a abstract class

2) use it on method --> pure virtual function


note: Java doesn't support multiple inheritance

Visbility:
private
public
protected: visible to all classes within the same package + inherited classes
default:  visible to all classes within the same package

=====================

Realization relationship

A Component will realize the behaviour specified by other component in order to communicate

Program to contract.

In java as in real world we use interfaces for this.

interface EmployeeDao {
    void addEmployee(Employee e);
}


Why should we program to interface?
1) DESIGN
2) IMPLEMENTATION
3) TESTING
4) INTEGRATION
5) LOOSE COUPLING

interfaces are like complete abstract classes, can't instantiate 

interface Flyable {
    fly();
}
class Eagle extends Bird implements FLyable {
    ///

    public void fly() {

    }
}


class AeroPlane extends Vehicle implements Flyable {
    ..
    public void fly() {

    }
}

Class.forName("java.lang.String"); // loads String class into METASPACE
Class.forName("com.adobe.prj.entity.Product"); 