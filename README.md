# Java

Banuprakash C

Full Stack Architect, Corporate Trainer

Co-founder & CTO: Lucida Technologies Pvt Ltd., 

Email: banuprakashc@yahoo.co.in; banuprakash.cr@gmail.com; banu@lucidatechnologies.com

https://www.linkedin.com/in/banu-prakash-50416019/

https://github.com/BanuPrakash/NCG_Java

===================================

Softwares Required:
1)  openJDK 17
https://jdk.java.net/java-se-ri/17

2) IntelliJ Ultimate edition 
https://www.jetbrains.com/idea/download/?section=mac


3) MySQL on Docker

Install Docker Desktop

Docker steps:

```
a) docker pull mysql

b) docker run --name local-mysql â€“p 3306:3306 -e MYSQL_ROOT_PASSWORD=Welcome123 -d mysql

container name given here is "local-mysql"

For Mac:
docker run -p 3306:3306 -d --name local-mysql -e MYSQL_ROOT_PASSWORD=Welcome123 mysql


c) CONNECT TO A MYSQL RUNNING CONTAINER:

$ docker exec -t -i local-mysql bash

d) Run MySQL client:

bash terminal> mysql -u "root" -p

mysql> exit

```

OOP 

--> Programs which resemble real world application
Object communicates with other object by sending messages. What messages an object can take is exposed thro its interface.

Object --> state and behaviour

SOLID design principle

S --> Single Responsibility
O --> open Close Principle [ Closed for Change  & open for extension]
L --> Liskov Substitution Principle
    Genralization and Specialization 
I --> Interface Seggregation
D --> Dependency Injection

===========================

Java ?
Java is a technology which has a platform to run/execute bytecode

Byte code can be generated by using different programming languages / Compilers

Java programming language --> JDK --> javac
Kotlin --> KDK --> Kotlin Compiler
Groovy --> GDK --> Groovy compiler

Compile time Environment:
```
public class Account {
    private double balance ; // state
    private static int count; // state of class
    
    public Account() {
        count++;
    }
    
    public void deposit(double amt) {
        this.balance += amt;
    }

    public double getBalance() {
        return this.balance;
    }

    public static int getCount() {
        return count;
    }
}

javac Account.java ---> Account.class


public class AccountExample {
    public static void main(String[] args) {
        Account rahulAcc = new Account();
        rahulAcc.deposit(45000);

        System.out.println(Account.getCount()); // 1
        Account swethaAcc = new Account();
        swethaAcc.deposit(50000);

        System.out.println(swethaAcc.getBalance());
         System.out.println(Account.getCount()); // 2
    }
}

javac AccountExample.java --> AccountExample.class

```

JRE --> Java Runtime Environment

1) ClassLoader
    findLoadedClass(), 
    loadClass(), --> Classpath ENV variable
    findSystemClass()
    defineClass() --> Convert Bytecode to system specific DataStructure

2 java AccountExample [JRE --> classLoader]
2.1) classloader
2.2) Main Thread is started --> Unit of Work

 public void deposit(double amt) {
translate to:
public void deposit(Account this, double amt) {
    this.balance += amt;
}
context.behaviour(arguments);
rahulAcc.deposit(45000); ==> deposit(rahulAcc, 45000);

===========

Logically Grouping of classes/Object
1) Entity class
    business data
    Example:
    a) Uber
    Customer, Vehicle, Driver, Payment, Trip ...

    b) Swiggy
    Customer, Product, Order, LineItemm Payment, ShipAddress

    These classes contains instance variables / state, constructorss, getters and setters, hashCode, equals

    ``
    public class Customer {
        String email;
        String firstName;
        ...

    }
    ```
2) DAO: Data Access Object
    they contain CRUD operaions
    CREATE READ UPDATE and DELETE operations
    generally one per table
    ```
    public class CustomerDao {
        public void register(Customer c) {
            "INSERT into customers.."
    
        }

        public boolean login(Customer c) {
            select ...
        }
    }
    ```
3) Business Class:
    business logic
4) Service classes : are a facade over DAO and business class
    generally one per actor

```
    public class BankingService {

        public void transferFunds(Account fromAcc, Account toAcc, double amt) {
            accountDao.getBalance(fromAcc); // 
            businessLogic.checkEligible();
            accounDao.updateAccount(fromAcc);
            accountDao.updateAccount(toAcc);
            transactionDao.insertTx(fromAcc, toAcc);
            sendSMS()
            sendEMail();
        }

    }

```
5) Client
    Web Client / Desktop client / Mobile Client / Hardware ...

6) Utility classes : Helpers
7) Exception classes: to represent any abnormal condition in application
    Why?
    a) What went wrong
    b) Why?
    c) Where?

----

packages: folders for grouping related classes

``
com
 |
 adobe
    |
    aem
     |
     entity
        Customer.class
        Product.class
     dao
        CustomerDao.class
        Product.class
    service
        CustomerService.class

```

Relationship between Objects:
1) Generalization and Specialization
2) Realization
3) Uses A relationship
4) Association


Generalization and Specialization: Inheritance ==> IS A relationship

Mobile m = new Mobile(); memory is created for id, nam, price and connectivity
all the methods of Product + getter and setter for connectivity;

m.setPrice(3333); // is this valid?

Product p = new Mobile(); 
p.setPrice(4444); // valid
p.setConnectivty("5G"); ???? 
p.isExpensive(); // which method --> calls method in Mobile and not Product class --> dynamic binding

instance methods are dynamic binding / runtime binding
static methods are compile time bindings
all instance methods in Java are virtual by default.

static methods --> don't call overriding --> shadowing
variables --> shadowing

======

abstract keyword
1) use it with class to specify that it's too generic, can't exist in real world
can't instantiate a abstract class

2) use it on method --> pure virtual function


note: Java doesn't support multiple inheritance

Visbility:
private
public
protected: visible to all classes within the same package + inherited classes
default:  visible to all classes within the same package

=====================

Realization relationship

A Component will realize the behaviour specified by other component in order to communicate

Program to contract.

In java as in real world we use interfaces for this.

interface EmployeeDao {
    void addEmployee(Employee e);
}


Why should we program to interface?
1) DESIGN
2) IMPLEMENTATION
3) TESTING
4) INTEGRATION
5) LOOSE COUPLING

interfaces are like complete abstract classes, can't instantiate 

interface Flyable {
    fly();
}
class Eagle extends Bird implements FLyable {
    ///

    public void fly() {

    }
}


class AeroPlane extends Vehicle implements Flyable {
    ..
    public void fly() {

    }
}

Class.forName("java.lang.String"); // loads String class into METASPACE
Class.forName("com.adobe.prj.entity.Product");

=================================

Day 2

Recap:

Object --> state & behaviour

Template for Object
* Java / C++ / C# --> class
class Product {}
* JavaScript --> function
function Product() {}
* Oracle --> Type
Type Product 

===========
* all methods in interface by default are public and abstract

Fight f = new Hero();

f.fight();

f.swim();

Swim s = (Swim) f;

s.swim(); // works

public void fightSequence(Fight[] fight) {
    ...
}

Comparable interface --> 

```
class AddComputation implements Computation {
     @Override
            public int compute(int firstArg, int secondArg) {
                return firstArg + secondArg;
            }
}

class SubComputation implements Computation {
     @Override
            public int compute(int firstArg, int secondArg) {
                return firstArg - secondArg;
            }
}

Computation add = new AddComputation();
```

Annotation?
Metadata --> data about data.

1) Who uses it?
    * COMPILER
    * CLASSLOADER
    * RUNTIME [JRE]
2) Where can I use it?
    * TYPE --> class / interface / Annotation / Record / Enum
    * METHOD
    * FIELD
    * PARAMETER

@Override ==> Compiler and METHOD
@SuppressWarnings ==> Compiler

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.CLASS)
public @interface Platform {
    String value();
}

a = value;
value = x;

@Platform("android")
public class PubG extends Game {

}

Compiler --> keeps annotation in .class file

Classloader ==> Samsung / OnePlus

===========

Annotations contains properties; no fields and methods

Java Collection Framework
* interfaces 
* Implementation classes
* Utility / Algorithm classes

Data Containers:
array is a data container: --> size is fixed, adding at end, removing from end


Collection type:
1) List
* ordered
* allows index based operations
* duplicates are allowed
* can be re-ordered

ArrayList, LinkedList, vavr, Apache Collections

2) Set
* unique collection
* not ordered
* Can't re-order
3) Queue

Vector and Stack are legacy collection; very slow; allow methods of these collections are using locking mechanism to avoid data corruption
all methods are synchronized

Collections --> contains algorithms similar to Arrays

```
Usage:

1) BAD, not typesafe
ArrayList list = new ArrayList();
list.add("A");
list.add(new Product());
list.add(new Date());

if(list.get(0) instanceof Date) {
    Date d = (Date)list.get(0);
}

2) Typesafe --> BAD because changing implemention is difficult
ArrayList<String> list = new ArrayList<>();
list.add("A");
list.add(new Product()); // ERROR

3) Prefer
List<String> list = new ArrayList<>(); 
list.add("A");
list.add(new Product());

doTask(list);

public void doTask(List<String> list) {

}
```

HOF : High Order Functions

 higher-order function is a function that does at least one of the following: 
 * takes one or more functions as arguments, 
 * returns a function as its result. 
 
 All other functions are first-order functions. 

Commonly used HOF:
1) filter : subset
2) map: transform
3) forEach: iterate
4) reduce: aggregate [sum, avg, count, ...]
5) limit: 10
6) skip
7) collect

https://rxmarbles.com/

========================

Web application with database connectivity

Java build tools: Maven/Gradle
* Uniformity across all team members
* Manage dependecies [ libraries ]
* automate tasks like compile / testing / Static code analysis / build / package

pom.xml or build.gradle
Project Object Model : file where depdenencies and goals are configured

======

Uber
    auth module
    driver module
    customer module

JDBC: Java Database Connectivity
integration library to connect to RDBMS.

Java provides interfaces; implementation classes are provided by database vendors

Oracle / MySQL / MS-SQL / Postgres

Steps:
    1) Establish a connection to database

    Connection con = DriverManager.getConnection(URL, USER, PWD);
    getConnection is factory method

    2) SEND SQL statements
    2.1) Statement
        use this if SQL is same for every request
        "select * from products"

    2.2) PreparedStatement
     use this if SQL takes IN parameter

     "select * from accouts where accountID = ?"

     "insert into products values (?, ?, ?)"

    2.3) CallableStatement
        to invoke stored procedures of database
        call SelectAllCustomers('BLORE', 5600001);

        ```
        CREATE PROCEDURE SelectAllCustomers @City nvarchar(30), @PostalCode nvarchar(10)
            AS
            SELECT * FROM Customers WHERE City = @City AND PostalCode = @PostalCode
        GO;
```
    3) Statement / PreparedStatement / CallableStatement returns
        3.1) int : for UPDATE / INSERT and DELETE statements ==> number of records effected
        3.2) ResultSet for SELECT statement
        ResultSet is a cursor to fetched records
        boolean next();

        rs.getString("CustomerName")
        rs.getString(1);
        
    4) close the resources --> done in finally block

        try {

        } catch(Exception ex) {

        } finally {
            con.close();
        }

======

```
 <build>
        <pluginManagement>
            <plugins>
                <plugin>
                    <groupId>org.apache.maven.plugins</groupId>
                    <artifactId>maven-compiler-plugin</artifactId>
                    <version>3.11.0</version>
                    <configuration>
                        <source>17</source>
                        <target>17</target>
                    </configuration>
                </plugin>
                <plugin>
                    <groupId>org.apache.maven.plugins</groupId>
                    <artifactId>maven-war-plugin</artifactId>
                    <version>3.4.0</version>
                    <configuration>
                        <failOnMissingWebXml>false</failOnMissingWebXml>
                    </configuration>
                </plugin>
                <!-- embedded JETTY server -->
                <plugin>
                    <groupId>org.eclipse.jetty</groupId>
                    <artifactId>jetty-maven-plugin</artifactId>
                    <version>11.0.15</version>
                </plugin>
            </plugins>
        </pluginManagement>
    </build>
```

Day 3:

JDBC

% docker exec -it local-mysql bash
# mysql -u root -p
mysql> create database JAVA_SPRING;
mysql> use JAVA_SPRING;

mysql> create table products (id int PRIMARY KEY AUTO_INCREMENT, name VARCHAR(100), price double);

mysql> insert into products values (0, 'iPhone 15', 89000.00);


mysql> insert into products values (0, 'Samsung OLED', 256000.00);

mysql> select * from products;
+----+--------------+--------+
| id | name         | price  |
+----+--------------+--------+
|  1 | iPhone 15    |  89000 |
|  2 | Samsung OLED | 256000 |
+----+--------------+--------+


